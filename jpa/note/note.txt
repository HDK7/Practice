
1. XToOne 어노테이션은 LAZY 설정 필요
2. persist객체 중 cascade가 필요하다면 설정 
3. 상관관계 메소드 설정 필요
4. 컬렉션은 필드에서 초기화 해야함. Hibernate가 감싸 변환 하기 때문에 처음부터 설정.
연관관계 편의 메소드는 연관관계 주입이나 이런걸 다 떠나서 넣어줘야 찾을수 있음.
//연관관계에서는 객체관점에서도 똑같이 값을 세팅해주는 것이 좋다.
주인 관계 개념 한번더 상기
team class에 List<Member>에 member를 넣어도 DB에 저장되지 않는다.
Member class에서 List<Team>에 team을 추가하면 DB에 저장된다.
https://private-space.tistory.com/87 참고..
테이블 관점에서는 Member 클래스의 team 필드만 바꿔주면 되지만 JPA로 불러왔으나 아직 값이 변하지
않은 순수 자바 객체인 경우 문제가 생길 수 있다. 그리므로 연관관계 편의 메소드를 만든다.
@OneToOne @ManyToOne 같은 경우 엔티티간의 관계를 맵핑 해주는 역할이다. 안쓰면 칼럼인줄 알것이다.
Respository, Service, Entitiy에 메소드를 만드는 기준은?
Entitiy 관계 종류 및 설정방법 N:1 1:N 1:1 관계 설정들
동적쿼리 작성방법 //querydsl 이라는 방법이 있음.
핵심기술은 대부분 Entitiy에 만드므로 단위테스트로 엔티티 핵심 메소드들을 꼼꼼히 테스트하는게 좋다

6. 데이터 수정시 변경감지와 병합을 맞게 사용해야 한다. merge는 모든 변수를 업데이트 하므로 null을 조심해야한다.
개념은 DB에서 조회후 set해주는 것으로 준영속성을 영속성을 부여하는 것이라고 생각하면 된다. 최대한 안쓰는것이 좋다.
그래서 mrege 보다는 findOne 후 한땀한땀 set 해주는 것이 좋다. 영속성 객체를 직접 사용하는 것이므로

7. 그리고 set보다는 change 메소드 등을 만들어 역추적이 가능하도록 한는 것이 좋다.
엔티티에 setter를 만들지 않는 것이 좋다. 메소드를 만들어 한번에 받거나 하는 것을 추천

8. 생성자 주입방식을 권장. 그래야 테스트 등에서 매개변수를 넣어주면서 한번더 상기 할 수 있다.
또한 final을 통해 주입이 되지 않을 시 컴파일로 확인가능하므로 해주는 것이 좋다.
참고 생성자가 한개일시 자동 Autowired 된다.
참고) @RequiredArgsConstructor 는 final이 붙은 변수만 생성자를 생성해 준다. lombock기능
스프링데이터JPA는 em도 @Autowired 로 주입해준다. 

9. 엔티티는 최대한 순수하게 유지하는 것이 좋다. View단과 연결될 시 지저분 해지기 쉽다.
DTO를 따로 만들어 줘서 form을 넘기는 것이 좋다.

정리 끝
